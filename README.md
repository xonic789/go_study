# Go basic
## build, install, run 차이점
- build는 go 소스코드를 가지고 실행 가능한 파일(exe)로 생성해줌. (테스트, 컴파일용 명령어)
- install은 pkg(외부 라이브러리) 등을 모두 합쳐서 하나의 application이라 생각하고, binary 파일로 만들어 줌.
- run은 간단하게 터미널에서 실행해볼 수 있는 명령어

## Go 장점 및 특징
- 간결한 문법 및 단순함
- 병행 프로그래밍 지원
  - 타 언어에서는 쓰레드를 사용하여 멀티 쓰레드, 즉 병렬 프로그래밍을 가능케함.
  - 하지만 고에선 고루틴이 지원되기 때문에 따로 쓰레드를 생성할 필요 없이 병행 프로그래밍 가능.
- 정적 타입 및 동적 실행
- 간편한 협업 지원
- 컴파일 및 실행속도 빠름
- 제네릭 및 예외 처리 미지원
- 컨벤션 통일

### 변수 var, 상수 const
- 변수에서 shortVariable 기억! => 스택 {} 안 스코프를 가진다.
- 여러 개를 선언하고 다른 타입을 할당할 수 있음.
- 다른 언어들과 마찬가지로 const 는 선언과 동시에 초기화 필요, 재할당 X

### 제어문

#### 1. if
- if, if else, if else if 가능. 중괄호 위치 지정, 생략 불가능

#### 2. switch
- switch 뒤 Expression 생략 가능
- case 뒤 Expression 사용 가능
- 자동 break 때문에 fallthrough 존재
- type 분기 -> 값이 하닌 변수 Type으로 분기 가능

#### 3. for
- go에서 제공하는 유일한 반복문이다.
- 다른 프로그래밍 언어에서 while 과 비슷하게 사용 가능.

### Go 문법 특징 정리
- 주석 : // /**/
- 세미콜론
  - 컴파일러가 자동으로 세미콜론 추가하므로 추가하면 에러
- 연산[증감, 전치]
  - 전치 연산자 (++i) 비허용, 후치 연산자 (i++) 반환 값 없음.
- 코드 자동 서식
  - gofmt가 자동으로 파일의 포맷팅을 해줌.


### package
- Go의 지향점은 하나의 모듈은 응집도가 높고 결합도가 낮은, 즉 우리가 지향점으로 삼고 있는 소프트웨어 아키텍쳐와 비슷하다고 할 수 있다.
- 하나의 package 는 하나의 기능을 표출할 수 있어야함.
- 작은 패키지를 결합해서 프로그램을 작성 할 것을 권고하고 있다.
**네이밍 규칙**
- 대문자 public, 소문자 private 접근 제어를 가짐
- 별칭(alias) 패키지 사용 가능.  
**초기화 메서드**
- `func init() {}` : main보다 먼저 호출됨.
- package import 하면, init method가 있다면 호출된다.
- [https://go.dev/doc/effective_go#initialization](https://go.dev/doc/effective_go#initialization)

### 데이터 타입
#### Boolean 
- 암묵적 형 변환 X : 0, Nil -> false 변환 없음.
- 논리 연산자 &&, ||, ! 연산 가능
- 논리 연산자 >, <, !=, ==, <=, >= 

### Numberic
- 정수, 실수, 복소수
- 32bit, 64bit, unsigned(양수)
- 정수: 8진수(0), 16진수(0x), 10진수 => 시작하는 prefix가 0이면 8진수, 0x이면 16진수이다.
- rune(유니코드), byte(아스키) 정수 할당 가능
- 실수(부동소수점)
  - float32(7자리), float64(15자리)
    - 32 -> 64 변환할 때 주의!
- 같은 크기의 데이터 타입을 연산할 때는 캐스팅 후 해야할 것.
  - 같은 타입만 연산 가능
- 비트 오버플로우 유의!


### String
- 큰 따옴표 "", 백스쿼트 ``
- 문자 char 타입 존재하지 않음. -> rune(int32)로 문자 코드 값으로 표현
- 문자 : ''로 작성
- 자주 사용하는 escape : \\\ , \\`, \\"
- len 함수는 바이트를 리턴해준다.
- len 배열을 넣으면 길이를 리턴해주기 때문에, 한글 스트링을 rune 배열로 만들고 호출하면 길이를 리턴해준다.
#### 문자열 표현
- UTF-8 인코딩 (유니코드 문자 집합) -> 바이트 수 주의!
#### 문자열 연산
- 일반 + 연산도 가능하지만, 배열을 통해 append하고 Join을 이용하는 것이 유리


## data structure
### array
- 값 타입이다
- 예를 들어 `arr2 := arr1` 로 할당시키면 다른 주소에 배열을 복사한다.
- 배열은 용량, 길이가 항상 같음


### 배열 슬라이스 비교
- 길이고정 vs 길이가변
- 값 타입 vs 참조 타입
- 복사 전달 vs 참조 값 전달
- 전체 비교 연산자 사용 가능 vs 비교 연산자 사용 불가
- 대부분 슬라이스 사용한다.

### slice
- 참조 타입이다.
- []타입, []타입{초기화} 로 선언 및 할당 가능
- make 함수로 할당 가능
- 부분적으로 슬라이스 추출은 참조 타입으로써, 원본 데이터가 변경되니 주의.

### map
- 래퍼런스 타입 (참조 값 전달)
- 비교 연산자 사용 불가능(참조 타입이므로)
- 특징 : 참조타입(Key)로 사용 불가능, 값(Value)으로 모든 타입 사용 가능
- make 함수 및 축약(리터럴)로 초기화 가능
- 순서가 없다.
- 없는 키를 조회하면 default 초기화 값을 리턴해주기 때문에 두 번째 리턴 값으로 키 존재 유무 확인해야함.

### pointer
- 포인터지원 X(파이썬, C#, JAVA 등)
- 주소 값은 직접 변경 불가능
- *(애스터리스크)로 사용
- nil로 초기화 (nil == 0)
```go
var a *int // 포인터형 변수 선언, 당연히 a의 메모리 주소도 가지고 있으며, 다른 변수의 메모리 주소를 할당.
var a *int = new(int) 

```

### function
- 선언 : func 키워드로 선언
- func 함수명(매개변수) (반환타입 or 반환 값 변수명) : 반환 값 존재
- func 함수명() (반환타입 or 반환 값 변수명) : 매개 변수 없음, 반환 값 존재
- func 함수명(매개변수) : 매개변수 존재, 반환 값 없음
- func 함수명() : 매개변수 없음, 반환 값 없음
- 타 언어와 달리 반환 값(return value) 다수 가능

### defer
- Defer 함수 실행 (지연)
- Defer를 호출한 함수가 종료되기 직전에 호출된다.
- 타 언어의 Finally 문과 비슷
- 주로 리소스 반환, 열린 파일 닫기, Mutex 잠금 해제

### closure
- 익명함수 사용할 경우 함수를 변수에 할당해서 사용가능
- 함수 안에서 함수를 선언 및 정의 가능 -> 이 때 외부 함수에 선언 된 변수에 접근 가능한 함수
- 함수가 선언되는 순간에 함수가 실행 될 때 실체의 외부 변수에 접근하기 위한 스냅샷(객체)
- 함수를 호출할 때 이전에 존재했던 값을 유지하기 위해서 -> 비동기, 누적카운트, 무분별한 전역변수 남발...
- 남발 -> 객체들이 메모리에 존재하므로, -> 메모리 부족, 오버플로우 현상, 자원을 무분별하게 사용 가능성
- 클로저 정확하게 이해하고 사용
- 예제 코드
```go
m, n := 5, 10            // 변수가 캡쳐 (선언과 동시에 캡쳐됨.)
sum := func(c int) int { //익명함수 선언과 동시에 할당
  return m + n + c // 지역변수 소멸 되지 않음. (함수 호출시마다 사용 가능)
}
// 캡쳐됐다는 말은 변수의 메모리 주소를 함수를 선언할 때 할당한다.(캡쳐한다)
```

## 사용자 정의 타입
- Go는 객체 지향 타입을 구조체로 정의한다 (클래스, 상속 개념 없음)
- 객체지향 -> 클래스(속성 : 멤버변수, 기능(상태 : 메소드)) : 코드의 재사용성, 코드의 관리 용이, 신뢰성이 높은 프로그래밍
- Go는 전형적인 객체지향의 특징을 가지고 있지 않지만, 인터페이스 -> 다형성 지원, 구조체를 클래스 형태의 코딩 가능
- 객체지향의 기본 개념 -> Go에서 포함하고 있다. -> 객체 지향 프로그래밍 언어이다
- 상태, 메소드 분리해서 정의(결합성 없음)
- 사용자 정의 타입 : 구조체, 인터페이스, 기본타입(int, float, string), 함수
- 구조체와 -> 메소드 연결을 통해서 타 언어의 클래스 형식처럼 사용 가능하다!(객체지향)
-  리시버(구조체 메소드) 전달(값, 참조) 형식
- 함수는 기본적으로 값 호출 -> 변수의 값이 복사 후 내부 전달(원본 수정X) -> 맵, 슬라이스 등은 참조 전달
- 리시버(구조체)도 마찬가지로 포인터를 활용해서 메소드내에서 원본 수정 가능
  - 반대로 말하면, 값 전달으로는 원본 값 수정이 되지 않음 (객체의 상태 수정 X)